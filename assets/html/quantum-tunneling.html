<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quantum Field Visualization</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; background: #020204; }
    #container { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <div id="container"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
(function() {
  const container = document.getElementById('container');
  const width = container.clientWidth;
  const height = container.clientHeight;

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x020204);

  const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 100);
  camera.position.set(0, 1.5, 4.5);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(width, height);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container.appendChild(renderer.domElement);

  // Core Vertex Shader
  const coreVertexShader = `
    uniform float uTime;
    varying vec2 vUv;
    varying vec3 vNormal;
    varying float vDistortion;

    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
    
    float snoise(vec3 v) { 
      const vec2 C = vec2(1.0/6.0, 1.0/3.0);
      const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
      vec3 i = floor(v + dot(v, C.yyy));
      vec3 x0 = v - i + dot(i, C.xxx);
      vec3 g = step(x0.yzx, x0.xyz);
      vec3 l = 1.0 - g;
      vec3 i1 = min(g.xyz, l.zxy);
      vec3 i2 = max(g.xyz, l.zxy);
      vec3 x1 = x0 - i1 + C.xxx;
      vec3 x2 = x0 - i2 + C.yyy;
      vec3 x3 = x0 - D.yyy;
      i = mod289(i);
      vec4 p = permute(permute(permute(
                i.z + vec4(0.0, i1.z, i2.z, 1.0))
              + i.y + vec4(0.0, i1.y, i2.y, 1.0))
              + i.x + vec4(0.0, i1.x, i2.x, 1.0));
      float n_ = 0.142857142857;
      vec3 ns = n_ * D.wyz - D.xzx;
      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
      vec4 x_ = floor(j * ns.z);
      vec4 y_ = floor(j - 7.0 * x_);
      vec4 x = x_ * ns.x + ns.yyyy;
      vec4 y = y_ * ns.x + ns.yyyy;
      vec4 h = 1.0 - abs(x) - abs(y);
      vec4 b0 = vec4(x.xy, y.xy);
      vec4 b1 = vec4(x.zw, y.zw);
      vec4 s0 = floor(b0) * 2.0 + 1.0;
      vec4 s1 = floor(b1) * 2.0 + 1.0;
      vec4 sh = -step(h, vec4(0.0));
      vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
      vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
      vec3 p0 = vec3(a0.xy, h.x);
      vec3 p1 = vec3(a0.zw, h.y);
      vec3 p2 = vec3(a1.xy, h.z);
      vec3 p3 = vec3(a1.zw, h.w);
      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
      p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
      m = m * m;
      return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
    }

    void main() {
      vUv = uv;
      vNormal = normalize(normalMatrix * normal);
      float noise = snoise(position * 3.0 + uTime * 0.5);
      vDistortion = noise;
      vec3 newPos = position + normal * noise * 0.2;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);
    }
  `;

  const coreFragmentShader = `
    uniform float uTime;
    varying vec3 vNormal;
    varying float vDistortion;

    void main() {
      float wave = sin(vDistortion * 20.0 + uTime * 2.0);
      float band = smoothstep(0.4, 0.6, wave);
      vec3 viewDir = vec3(0.0, 0.0, 1.0);
      float fresnel = pow(1.0 - dot(vNormal, viewDir), 2.0);
      vec3 colorA = vec3(0.1, 0.8, 0.9);
      vec3 colorB = vec3(0.9, 0.1, 0.8);
      vec3 finalColor = mix(colorA, colorB, vDistortion * 0.5 + 0.5);
      float alpha = (fresnel + band * 0.5) * 0.6;
      gl_FragColor = vec4(finalColor * 2.0, alpha);
    }
  `;

  const rippleVertexShader = `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;

  const rippleFragmentShader = `
    uniform float uTime;
    varying vec2 vUv;

    void main() {
      vec2 centered = vUv - 0.5;
      float dist = length(centered) * 2.0;
      float ripple = sin(dist * 20.0 - uTime * 3.0);
      ripple = pow(0.5 + 0.5 * ripple, 8.0);
      float decay = exp(-dist * 3.0);
      vec3 color = vec3(0.4, 0.6, 1.0);
      float alpha = ripple * decay * 0.8;
      gl_FragColor = vec4(color, alpha);
    }
  `;

  // Quantum Core
  const coreGeo = new THREE.IcosahedronGeometry(1.0, 32);
  const coreMat = new THREE.ShaderMaterial({
    vertexShader: coreVertexShader,
    fragmentShader: coreFragmentShader,
    uniforms: { uTime: { value: 0 } },
    transparent: true,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false,
  });
  const core = new THREE.Mesh(coreGeo, coreMat);
  scene.add(core);

  // Evanescent Field
  const fieldGeo = new THREE.PlaneGeometry(8, 8);
  const fieldMat = new THREE.ShaderMaterial({
    vertexShader: rippleVertexShader,
    fragmentShader: rippleFragmentShader,
    uniforms: { uTime: { value: 0 } },
    transparent: true,
    blending: THREE.AdditiveBlending,
    side: THREE.DoubleSide,
    depthWrite: false,
  });
  const field = new THREE.Mesh(fieldGeo, fieldMat);
  field.rotation.x = -Math.PI / 2;
  field.position.y = -0.5;
  scene.add(field);

  // Tunneling Particles
  const particleCount = 120;
  const pPos = [];
  const pPhase = [];

  for (let i = 0; i < particleCount; i++) {
    const r = 1.5 + Math.random() * 3.0;
    const theta = Math.random() * Math.PI * 2;
    const y = (Math.random() - 0.5) * 1.5;
    pPos.push(r * Math.cos(theta), y, r * Math.sin(theta));
    pPhase.push(Math.random() * Math.PI * 2);
  }

  const pGeo = new THREE.BufferGeometry();
  pGeo.setAttribute('position', new THREE.Float32BufferAttribute(pPos, 3));
  pGeo.setAttribute('aPhase', new THREE.Float32BufferAttribute(pPhase, 1));

  const pMat = new THREE.ShaderMaterial({
    vertexShader: `
      uniform float uTime;
      attribute float aPhase;
      varying float vAlpha;
      void main() {
        vec3 pos = position;
        float angle = uTime * 0.2 + aPhase;
        float ca = cos(angle);
        float sa = sin(angle);
        vec3 rotatedPos = vec3(
          pos.x * ca - pos.z * sa,
          pos.y,
          pos.x * sa + pos.z * ca
        );
        vec4 mvPosition = modelViewMatrix * vec4(rotatedPos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
        float exist = sin(uTime * 3.0 + aPhase * 5.0);
        exist = smoothstep(0.0, 0.1, exist);
        gl_PointSize = (4.0 * exist) * (10.0 / -mvPosition.z);
        vAlpha = exist;
      }
    `,
    fragmentShader: `
      varying float vAlpha;
      void main() {
        float r = distance(gl_PointCoord, vec2(0.5));
        if (r > 0.5) discard;
        float glow = 1.0 - (r * 2.0);
        glow = pow(glow, 2.0);
        gl_FragColor = vec4(0.8, 0.9, 1.0, vAlpha * glow);
      }
    `,
    uniforms: { uTime: { value: 0 } },
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
  });
  const particles = new THREE.Points(pGeo, pMat);
  scene.add(particles);

  // Mouse
  let mouseX = 0, mouseY = 0;
  document.addEventListener('mousemove', (e) => {
    mouseX = (e.clientX / width) - 0.5;
    mouseY = (e.clientY / height) - 0.5;
  });

  // Animation
  const clock = new THREE.Clock();

  function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    coreMat.uniforms.uTime.value = time;
    fieldMat.uniforms.uTime.value = time;
    pMat.uniforms.uTime.value = time;

    camera.position.x += (mouseX * 5 - camera.position.x) * 0.02;
    camera.position.y += (-mouseY * 2 + 1.5 - camera.position.y) * 0.02;
    camera.lookAt(0, 0, 0);

    core.rotation.y = time * 0.1;
    core.rotation.z = time * 0.05;

    renderer.render(scene, camera);
  }
  animate();

  // Resize
  window.addEventListener('resize', () => {
    const w = container.clientWidth;
    const h = container.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h);
  });
})();
  </script>
</body>
</html>
