<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garden of Knowledge - Interactive</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #050a0e; 
            overflow: hidden; 
            width: 100vw; 
            height: 100vh;
        }
        canvas { display: block; outline: none; }
        #overlay {
            position: absolute; bottom: 20px; left: 20px;
            color: #4a6b3a; font-family: monospace; font-size: 12px;
            pointer-events: none; opacity: 0.7;
            text-shadow: 0 0 5px #000;
        }
    </style>
</head>
<body>
    <div id="overlay">
        SYSTEM: KNOWLEDGE GARDEN<br>
        STATUS: INTERACTIVE MODE<br>
        [DRAG] ORBIT &nbsp; [SCROLL] ZOOM
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
    (function() {
        // --- 1. Scene Setup ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050a0e, 0.02); // 霧の濃さを調整
        scene.background = new THREE.Color(0x050a0e);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 4, 16); // 初期位置

        // --- OrbitControls Setup ---
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // 慣性を有効化（滑らかさ）
        controls.dampingFactor = 0.05;
        controls.autoRotate = true; // 自動回転
        controls.autoRotateSpeed = 0.5; // ゆっくり回る
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // 地面より下に行かないように制限
        controls.minDistance = 5; // 近づきすぎない
        controls.maxDistance = 40; // 離れすぎない
        controls.target.set(0, 3, 0); // 木の中心を見る

        // --- 2. Lights ---
        const ambientLight = new THREE.AmbientLight(0x4a5d7f, 0.4); 
        scene.add(ambientLight);

        const treeLight = new THREE.PointLight(0x8f9c5a, 1.5, 25);
        treeLight.position.set(0, 4, 0);
        scene.add(treeLight);
        
        const sporeLight = new THREE.PointLight(0x8cf29c, 0.6, 15);
        sporeLight.position.set(3, 6, 3);
        scene.add(sporeLight);

        // --- 3. The Tree (Central Knowledge) ---
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        const treeMat = new THREE.MeshStandardMaterial({
            color: 0x1a1510,       
            emissive: 0x4a6b3a,    
            emissiveIntensity: 0.5,
            roughness: 0.9,
            metalness: 0.1
        });

        function createBranch(height, radius, twists) {
            const points = [];
            const segments = 50;
            for (let i = 0; i <= segments; i++) {
                const t = i / segments;
                const angle = t * twists * Math.PI * 2;
                const r = radius * (1 - t * 0.7);
                // 自然な揺らぎ
                const x = Math.cos(angle) * r + Math.sin(t * 12) * 0.3;
                const z = Math.sin(angle) * r + Math.cos(t * 9) * 0.3;
                const y = t * height;
                points.push(new THREE.Vector3(x, y, z));
            }
            const curve = new THREE.CatmullRomCurve3(points);
            return new THREE.TubeGeometry(curve, segments, radius * 0.25, 8, false);
        }

        for(let i=0; i<7; i++) {
            const h = 7 + Math.random() * 5;
            const geo = createBranch(h, 1.2 + Math.random(), 1.5 + Math.random());
            const mesh = new THREE.Mesh(geo, treeMat);
            mesh.rotation.y = (i / 7) * Math.PI * 2;
            treeGroup.add(mesh);
        }

        // --- 4. Tablets (Flat Files) ---
        const tabletGroup = new THREE.Group();
        scene.add(tabletGroup);

        const tabletGeo = new THREE.BoxGeometry(0.7, 1.0, 0.08);
        const tabletMat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.8
        });
        const runeGeo = new THREE.PlaneGeometry(0.4, 0.03);
        const runeMat = new THREE.MeshBasicMaterial({ color: 0x6abf69, transparent: true, opacity: 0.6 });

        for(let i=0; i<24; i++) {
            const tablet = new THREE.Mesh(tabletGeo, tabletMat);
            
            const theta = Math.random() * Math.PI * 2;
            const r = 2.8 + Math.random() * 3.5;
            const y = 1.5 + Math.random() * 5.0;
            
            tablet.position.set(Math.cos(theta) * r, y, Math.sin(theta) * r);
            tablet.rotation.set(Math.random()*0.3, Math.random()*Math.PI*2, Math.random()*0.1);
            
            // Runes (Text lines)
            for(let j=0; j<6; j++) {
                const rune = new THREE.Mesh(runeGeo, runeMat);
                rune.position.set(0, (j-2.5)*0.12, 0.05);
                rune.scale.x = 0.3 + Math.random() * 0.7;
                tablet.add(rune);
            }

            // Roots connection
            const linePoints = [
                new THREE.Vector3(0, 0.5, 0),
                new THREE.Vector3(0, y + 2, 0).sub(tablet.position).multiplyScalar(0.6)
            ];
            const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
            const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: 0x4a6b3a, transparent: true, opacity: 0.2 }));
            tablet.add(line);

            // Add slight individual motion data
            tablet.userData = { 
                speedY: 0.002 + Math.random() * 0.003,
                offset: Math.random() * 10
            };

            tabletGroup.add(tablet);
        }

        // --- 5. Ruins (Distant Background) ---
        const ruinGroup = new THREE.Group();
        scene.add(ruinGroup);
        const ruinMat = new THREE.MeshBasicMaterial({ color: 0x020406 }); // Silhouette
        
        for(let i=0; i<10; i++) {
            const w = 4 + Math.random() * 8;
            const h = 15 + Math.random() * 25;
            const ruin = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), ruinMat);
            const dist = 35 + Math.random() * 20;
            const angle = Math.random() * Math.PI * 2;
            
            ruin.position.set(Math.cos(angle)*dist, h/2 - 5, Math.sin(angle)*dist);
            ruin.rotation.y = Math.random() * Math.PI;
            ruinGroup.add(ruin);
        }

        // --- 6. Spores (Particles) ---
        function getGlowSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0, 16,16,16);
            g.addColorStop(0, 'rgba(200, 255, 200, 1)');
            g.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        const particleCount = 800;
        const pGeo = new THREE.BufferGeometry();
        const pPos = new Float32Array(particleCount * 3);
        const pVel = [];

        for(let i=0; i<particleCount; i++) {
            pPos[i*3] = (Math.random() - 0.5) * 25;
            pPos[i*3+1] = Math.random() * 12;
            pPos[i*3+2] = (Math.random() - 0.5) * 25;
            pVel.push({
                y: 0.003 + Math.random() * 0.008,
                x: (Math.random() - 0.5) * 0.002,
                z: (Math.random() - 0.5) * 0.002,
                offset: Math.random() * 100
            });
        }
        pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
        
        const pMat = new THREE.PointsMaterial({
            color: 0x8cf29c,
            size: 0.25,
            map: getGlowSprite(),
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const particles = new THREE.Points(pGeo, pMat);
        scene.add(particles);

        // --- 7. Ground ---
        const planeGeo = new THREE.PlaneGeometry(120, 120, 32, 32);
        // Slightly uneven ground
        const posAttr = planeGeo.attributes.position;
        for(let i=0; i<posAttr.count; i++) {
            posAttr.setZ(i, posAttr.getZ(i) + Math.random() * 0.5); // Add noise to Z (which becomes Y after rotation)
        }
        planeGeo.computeVertexNormals();

        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x0a141a, 
            roughness: 0.8, 
            metalness: 0.1,
            flatShading: true
        });
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = -1;
        scene.add(plane);


        // --- Animation Loop ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // Update Controls
            controls.update();

            // Tree Breathing
            const breath = (Math.sin(time * 0.6) * 0.5 + 0.5); 
            treeMat.emissiveIntensity = 0.2 + breath * 0.3; 

            // Tablets Floating
            tabletGroup.children.forEach((tab) => {
                tab.position.y += Math.sin(time + tab.userData.offset) * 0.002;
                tab.rotation.y += 0.0005;
            });

            // Spores Flowing
            const posAttr = pGeo.attributes.position;
            for(let i=0; i<particleCount; i++) {
                let x = posAttr.getX(i);
                let y = posAttr.getY(i);
                let z = posAttr.getZ(i);

                y += pVel[i].y;
                x += Math.sin(time + y + pVel[i].offset) * 0.003; 
                z += Math.cos(time + y + pVel[i].offset) * 0.003;

                // Reset
                if(y > 12) {
                    y = -1;
                    x = (Math.random() - 0.5) * 15;
                    z = (Math.random() - 0.5) * 15;
                }
                posAttr.setXYZ(i, x, y, z);
            }
            posAttr.needsUpdate = true;

            renderer.render(scene, camera);
        }

        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    })();
    </script>
</body>
</html>