<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Three.js 逆写像（ヤコビアン）を動的表示 (threeJuliaInverseDynamic.html)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 6px 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
      color: #fff;
    }
    #overlay input {
      width: 60px;
      margin-right: 8px;
    }
    #overlay button {
      margin-right: 8px;
    }
  </style>

  <!-- ─────── Import Map 定義 ─────── -->
  <script type="importmap">
  {
    "imports": {
      "three":        "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <!-- ── ① Three.js の描画領域 ── -->
  <div id="canvas-container"></div>

  <!-- ── ② オーバーレイ UI：Julia 定数や世代数を変更できるようにする ── -->
  <div id="overlay">
    c = 
    <input type="number" id="input-re" step="0.01" value="-0.4" /> + 
    <input type="number" id="input-im" step="0.01" value="0.6" /> i,  
    maxIter = 
    <input type="number" id="input-iter" min="1" step="1" value="6" />
    <button id="btn-run">Run</button>
    <span id="status">(待機中)</span>
  </div>

  <!-- ── ③ Three.js 用のスクリプト（ヤコビアン版） ── -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { Complex } from './js/complex.js';
    import { animateInverseInverseJacobian } from './js/threeJulia-jacobian.js';

    // ── シーン / カメラ / レンダラー / OrbitControls をセットアップ ──
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, -3, 3);
    camera.up.set(0, 0, 1);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    // 軸ヘルパー (X: 赤, Y: 緑, Z: 青)
    const axesHelper = new THREE.AxesHelper(1.5);
    scene.add(axesHelper);
    // グリッドヘルパー (XY 平面に Z=0 のグリッド)
    const gridHelper = new THREE.GridHelper(2, 20, 0x333333, 0x222222);
    gridHelper.rotation.x = Math.PI / 2;
    scene.add(gridHelper);

    // ── ② 「Run」ボタンが押されたら動的アニメーション開始 ──
    const inputRe    = document.getElementById('input-re');
    const inputIm    = document.getElementById('input-im');
    const inputIter  = document.getElementById('input-iter');
    const btnRun     = document.getElementById('btn-run');
    const statusElem = document.getElementById('status');

    btnRun.addEventListener('click', async () => {
      // 既存のシーン上の Points オブジェクトをすべてクリア
      scene.traverse(obj => {
        if (obj.isPoints) scene.remove(obj);
      });

      // Julia 定数 c を入力値から生成
      const cre = parseFloat(inputRe.value);
      const cim = parseFloat(inputIm.value);
      const c = new Complex(cre, cim);

      // 最大世代数
      const maxIter = parseInt(inputIter.value, 10);

      statusElem.textContent = '(実行中…)';

      // 初期「単位円上の点群」を作成（200 サンプル）
      const initialCircle = [];
      const N = 200;
      for (let i = 0; i < N; i++) {
        const θ = (2 * Math.PI * i) / N;
        initialCircle.push(new Complex(Math.cos(θ), Math.sin(θ)));
      }

      try {
        await animateInverseInverseJacobian(scene, initialCircle, c, maxIter, 1000);
        statusElem.textContent = `(完了: maxIter=${maxIter})`;
      } catch (err) {
        console.error(err);
        statusElem.textContent = '(エラー発生)';
      }
    });

    // ── ③ Three.js のレンダリングループ ──
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ── ④ リサイズ対応 ──
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
  </script>
</body>
</html>

