<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Three.js 逆写像（陰陽マーク的な分岐）を Z に実部で可視化</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #000;
      color: #fff;
      display: flex;
      flex-direction: column;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0,0,0,0.6);
      padding: 6px 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
      color: #fff;
    }
    #overlay input {
      width: 60px;
      margin-right: 8px;
    }
    #overlay button {
      margin-right: 8px;
    }
  </style>

  <!-- ─────── Import Map 定義 ─────── -->
  <script type="importmap">
  {
    "imports": {
      "three":        "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <!-- 【① 3D 描画領域】 -->
  <div id="canvas-container"></div>

  <!-- 【② オーバーレイ UI】 -->
  <div id="overlay">
    c = 
    <input type="number" id="input-re" step="0.01" value="-0.4" /> + 
    <input type="number" id="input-im" step="0.01" value="0.6" /> i,  
    maxIter = 
    <input type="number" id="input-iter" min="1" step="1" value="4" />
    <button id="btn-run">Run</button>
    <span id="status">(待機中)</span>
  </div>

  <!-- 【③ Three.js＋実部Z描画スクリプト】 -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { Complex } from './js/complex.js';
    import { animateInverseYinYang } from './js/threeJulia-yinyang.js';

    // ── シーン、カメラ、レンダラー、OrbitControls のセットアップ ──
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);

    const camera = new THREE.PerspectiveCamera(
      45,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.set(0, -3, 3);
    camera.up.set(0, 0, 1);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    // 軸ヘルパー (X: 赤, Y: 緑, Z: 青)
    const axesHelper = new THREE.AxesHelper(1.5);
    scene.add(axesHelper);
    // グリッドヘルパー (XY 平面に Z=0 のグリッド)
    const gridHelper = new THREE.GridHelper(2, 20, 0x333333, 0x222222);
    gridHelper.rotation.x = Math.PI / 2;
    scene.add(gridHelper);

    // ── 「Run」ボタン処理 ──
    const inputRe    = document.getElementById('input-re');
    const inputIm    = document.getElementById('input-im');
    const inputIter  = document.getElementById('input-iter');
    const btnRun     = document.getElementById('btn-run');
    const statusElem = document.getElementById('status');

    btnRun.addEventListener('click', async () => {
      // 既存の Points を削除
      scene.traverse(obj => {
        if (obj.isPoints) scene.remove(obj);
      });

      // 入力から Julia 定数 c を取得
      const cre = parseFloat(inputRe.value);
      const cim = parseFloat(inputIm.value);
      const c   = new Complex(cre, cim);

      // 逆写像の最大世代数
      const maxIter = parseInt(inputIter.value, 10);

      statusElem.textContent = '(実行中…)';

      // 初期：単位円の点群（200 サンプル）
      const initialCircle = [];
      const N = 200;
      for (let i = 0; i < N; i++) {
        const θ = (2 * Math.PI * i) / N;
        initialCircle.push(new Complex(Math.cos(θ), Math.sin(θ)));
      }

      try {
        await animateInverseYinYang(scene, initialCircle, c, maxIter, 800);
        statusElem.textContent = `(完了: maxIter=${maxIter})`;
      } catch (err) {
        console.error(err);
        statusElem.textContent = '(エラー発生)';
      }
    });

    // ── レンダリングループ ──
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ── リサイズ対応 ──
    window.addEventListener('resize', () => {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    });
  </script>
</body>
</html>
