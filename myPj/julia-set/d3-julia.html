<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>Three.js 逆写像アニメーション (Z→赤チャネル)＋凡例＋Pause/Stop</title>
  <!-- Google アナリティクス (gtag.js) 設定 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-WV09PB2PZT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-WV09PB2PZT');
  </script>
  
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
      position: relative;
    }
    /* Three.js のキャンバスは JS 側でここに append される */
    /* 凡例用 Canvas を右下に重ねて表示 */
    #legend-canvas {
      position: absolute;
      top: 20px;
      right: 20px;
      left: auto;
      bottom: auto;
      width: 60px;   /* 必要に応じて調整 */
      height: 300px;  /* 必要に応じて調整 */
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.3);
      z-index: 10;
      pointer-events: none; /* マウス操作を Three.js 側に透過 */
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(0,0,0,0.6);
      padding: 6px 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 14px;
      color: #fff;
    }
    #overlay input {
      width: 60px;
      margin-right: 8px;
      background: #222;
      border: 1px solid #444;
      color: #fff;
    }
    #overlay button {
      margin-right: 8px;
      background: #333;
      border: 1px solid #555;
      color: #fff;
      padding: 4px 8px;
      cursor: pointer;
    }
    #overlay button:hover {
      background: #444;
    }
  </style>

  <!-- ─── Import Map 定義 ─── -->
  <script type="importmap">
  {
    "imports": {
      "three":        "https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <!-- ─── 3D 描画領域 ─── -->
  <div id="canvas-container">
    <!-- Three.js の renderer.domElement は JS 側でここに append -->
    <canvas id="legend-canvas"></canvas>
    <!-- オーバーレイ UI -->
    <div id="overlay">
      c = 
      <input type="number" id="input-re" step="0.01" value="-0.4" /> + 
      <input type="number" id="input-im" step="0.01" value="0.6" /> i,  
      N = 
      <input type="number" id="input-n" min="10" step="10" value="90" />,  
      maxIter = 
      <input type="number" id="input-iter" min="1" step="1" value="12" />
      <br>
      <!-- ３つのボタンを追加 -->
      <button id="btn-run">Run</button>
      <button id="btn-pause" style="display:none;">Pause</button>
      <button id="btn-stop">Stop</button>
      <span id="status">(待機中)</span>
      <p>赤色は発散と収束の境界です</p>
      <p>ドラッグ、ホイールでカメラ（視点）を移動できます</p>
      <p>Stop を押すと初期状態に戻ります</p>
    </div>
  </div>

  <!-- ─── メインスクリプト読み込み ─── -->
  <script type="module">
    import { Complex } from './js/util/complex-number.js';
    import {
      initThree,
      animateLoop,
      runInverseAnimation,
      scene
    } from './js/3d/d3-main.js';

    // ───────── グローバルフラグ ─────────
    // HTML の window オブジェクトにフラグを用意
    window.isRunning = false; // アニメーションが一度も始まっていない or 停止された直後なら false
    window.isPaused  = false; // Pause 中なら true
    window.isStopped = false; // Stop リクエストがあれば true

    // ───────── Three.js 初期化 ─────────
    initThree();
    animateLoop();

    // ───────── UI 要素を取得 ─────────
    const inputRe   = document.getElementById('input-re');
    const inputIm   = document.getElementById('input-im');
    const inputN    = document.getElementById('input-n');
    const inputIter = document.getElementById('input-iter');
    const btnRun    = document.getElementById('btn-run');
    const btnPause  = document.getElementById('btn-pause');
    const btnStop   = document.getElementById('btn-stop');
    const status    = document.getElementById('status');

    // 凡例用 Canvas のコンテキスト
    const legendCanvas = document.getElementById('legend-canvas');
    const legendCtx    = legendCanvas.getContext('2d');

    // 凡例の最小・最大 Z 値を格納する変数
    let legendMinZ = 0;
    let legendMaxZ = 2.0;

    /**
     * drawLegend(minZ, maxZ)
     *  legendCanvas 全体に「青→赤」の縦グラデーションを描き、
     *  上下と中央に数値ラベルを表示する
     */
    function drawLegend(minZ, maxZ) {
      // Canvas の内部解像度をクライアント幅／高さに合わせる
      const cw = legendCanvas.clientWidth;
      const ch = legendCanvas.clientHeight;
      legendCanvas.width  = cw;
      legendCanvas.height = ch;

      // 上下にマージンを取る
      const margin = 10;
      const usableHeight = ch - 2 * margin;
      const steps = 100;

      // (1) 縦方向にグラデーションを塗り重ね
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;           // 0 → 1
        const hue = 240 - 240 * t;     // 240(青)→0(赤)
        legendCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        const y = margin + usableHeight * (1 - t);
        const sliceHeight = usableHeight / steps + 1;
        legendCtx.fillRect(0, y, cw, sliceHeight);
      }

      // (2) 枠線
      legendCtx.strokeStyle = '#fff';
      legendCtx.strokeRect(0, 0, cw, ch);

      // (3) 数値ラベル
      legendCtx.fillStyle = '#fff';
      legendCtx.font = '12px monospace';
      legendCtx.textAlign = 'right';
      legendCtx.textBaseline = 'middle';

      // 上端に maxZ
      legendCtx.fillText(maxZ.toFixed(2), cw - 4, margin);
      // 中央に中間値
      const midZ = (minZ + maxZ) / 2;
      legendCtx.fillText(midZ.toFixed(2), cw - 4, ch / 2);
      // 下端に minZ
      legendCtx.fillText(minZ.toFixed(2), cw - 4, ch - margin);
    }

    // 初期表示：凡例を一度描画しておく
    drawLegend(legendMinZ, legendMaxZ);

    // ───────── 各ボタンのイベントリスナ ─────────

    // ■ Run／Resume ボタン
    btnRun.addEventListener('click', async () => {
      if (!window.isRunning) {
        // ─── 未だ開始していない（または Stop 後の初期化状態）───
        window.isRunning = true;
        window.isPaused  = false;
        window.isStopped = false;

        // ボタン表示を切り替え
        btnRun.style.display   = 'none';
        btnPause.style.display = 'inline-block';

        // 入力値を取得して Julia 定数など作成
        const cre = parseFloat(inputRe.value);
        const cim = parseFloat(inputIm.value);
        const c   = new Complex(cre, cim);
        const N       = parseInt(inputN.value, 10);
        const maxIter = parseInt(inputIter.value, 10);

        status.textContent = '(実行中…)';
        try {
          // runInverseAnimation は { minZ, maxZ, totalPoints } を返す前提
          const { minZ, maxZ, totalPoints } = await runInverseAnimation(c, N, maxIter, 800);
          // 正常終了したら最初の状態に戻す
          window.isRunning = false;
          btnPause.style.display = 'none';
          btnPause.textContent   = 'Pause';
          btnRun.textContent     = 'Run';
          btnRun.style.display   = 'inline-block';

          // ステータス更新＆凡例再描画
          status.textContent = `(完了: N=${N}, maxIter=${maxIter}, 点数=${totalPoints})`;
          legendMinZ = minZ;
          legendMaxZ = maxZ;
          drawLegend(legendMinZ, legendMaxZ);
        } catch (err) {
          // Stop リクエストなどで中断された場合
          window.isRunning = false;
          btnPause.style.display = 'none';
          btnPause.textContent   = 'Pause';
          btnRun.textContent     = 'Run';
          btnRun.style.display   = 'inline-block';
          status.textContent = '(Stopped)';
        }
      } else if (window.isPaused) {
        // ─── 一時停止中（Resume）───
        window.isPaused = false;
        btnPause.textContent = 'Pause';
      }
    });

    // ■ Pause／Resume ボタン
    btnPause.addEventListener('click', () => {
      if (!window.isPaused) {
        // Pause 状態にする
        window.isPaused = true;
        btnPause.textContent = 'Resume';
        status.textContent   = '(Paused)';
      } else {
        // 再開（Resume）
        window.isPaused = false;
        btnPause.textContent = 'Pause';
        status.textContent   = '(実行中…)';
      }
    });

    // ■ Stop ボタン
    btnStop.addEventListener('click', () => {
      // 停止リクエストフラグを立てる
      window.isStopped = true;
      window.isPaused  = false;
      window.isRunning = false;

      // シーン上のすべての Points を削除
      const toRemove = [];
      scene.traverse(obj => {
        if (obj.isPoints) toRemove.push(obj);
      });
      for (const p of toRemove) scene.remove(p);

      // ボタン表示を初期状態に戻す
      btnPause.style.display = 'none';
      btnPause.textContent   = 'Pause';
      btnRun.textContent     = 'Run';
      btnRun.style.display   = 'inline-block';

      // ステータスを初期化
      status.textContent = '(待機中)';

      // 凡例も初期化して再描画
      legendMinZ = 0;
      legendMaxZ = 2.0;
      drawLegend(legendMinZ, legendMaxZ);

      // 入力フォームも任意で初期値に戻す
      inputRe.value   = '-0.4';
      inputIm.value   = '0.6';
      inputN.value    = '90';
      inputIter.value = '12';
    });
  </script>
</body>
</html>
